---
layout: default
title: "2.4 Type Juggling"
published: true
---

# 2.4 Type Juggling

In this video, we will look at type juggling, which is PHPâ€™s automatic type conversion in different contexts.

Type juggling happens when PHP converts a value to a different type automatically. This can be helpful, but it can also lead to surprises if you are not paying attention.

When a string is used in a math expression, PHP tries to convert it to a number.

```php
<?php
$total = "10" + 5;   // 15
$value = "7.5" * 2;  // 15
?>
```

If the string starts with a number, PHP uses that number. If it does not, in versions prior to 8.0, it became 0 in numeric context.

```php
<?php
$a = "42abc" + 1; // 43
$b = "abc" + 1;   // 1
?>
```

In PHP 8 and later, using non-numeric strings in arithmetic can trigger a warning. PHP still converts what it can, but you should not rely on partial conversions. Additionally, performing arithmetic on a string that cannot be converted to a number will result in a TypeError, which is ceases operation if not caught using the try/catch structure that we will be discussing much later in this course. Always validate or sanitize user input before math.

These are common surprises when math runs on formatted strings. PHP will stop at the first non-numeric character or treat the string as non-numeric.

```php
<?php
$withComma = "1,000" + 5; // 1 (stops at comma)
$withDollar = "$9.99" + 1; // 1 (non-numeric start)
$withPercent = "20%" + 5;  // 25 (uses leading number)
?>
```

Type juggling also happens in loose comparisons. The `==` operator converts types as needed, while `===` does not.

```php
<?php
var_dump(5 == "5");   // true
var_dump(5 === "5");  // false
?>
```

In boolean context, many values become either true or false. For example, 0, 0.0, an empty string, and "0" are false. Most other values are true.

```php
<?php
var_dump((bool) 0);      // false
var_dump((bool) "");    // false
var_dump((bool) "0");   // false
var_dump((bool) "PHP"); // true
var_dump((bool) 42);    // true
var_dump((bool) -1);   // true
?>
```

Type juggling is convenient, but it can hide bugs. When you care about both type and value, use strict comparisons and validate input explicitly.

As we'll see in a few weeks, most input from users comes as strings, so be cautious when using that data in math or comparisons. Always sanitize and validate input to ensure it meets your expectations.

PHP automatically converts types in numeric, comparison, and boolean contexts. Knowing when that happens helps you avoid surprises.
